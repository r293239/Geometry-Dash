<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Dash - Stereo Madness</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(180deg, #87ceeb 0%, #4682b4 50%, #2f4f4f 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            cursor: pointer;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #title {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #ffff00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
        }
        button {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            border-radius: 25px;
            font-size: 18px;
            cursor: pointer;
        }
        button:hover {
            background: #ff5252;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div>Progress: <span id="progress">0%</span></div>
        <div>Attempt: <span id="attempt">1</span></div>
    </div>
    
    <div id="title">STEREO MADNESS</div>
    
    <div id="gameOver">
        <h2>Game Over!</h2>
        <p>Progress: <span id="finalProgress">0%</span></p>
        <button onclick="restart()">Try Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to full screen
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Game state
        let gameRunning = true;
        let attempt = 1;
        let cameraX = 0;
        let gameSpeed = 6; // Slightly faster for authentic feel
        
        // Block size - authentic GD grid system (1 unit = 30px)
        const BLOCK_SIZE = 30;
        
        // Player - proper GD cube size
        const player = {
            x: 100,
            y: canvas.height - BLOCK_SIZE * 4, // Start on ground level
            width: BLOCK_SIZE,
            height: BLOCK_SIZE,
            velY: 0,
            jumping: false,
            onGround: true,
            rotation: 0,
            mode: 'cube',
            gravity: 0.8,
            jumpPower: -16 // Exactly 3 blocks high
        };
        
        // Ground level calculation
        const groundY = canvas.height - BLOCK_SIZE * 2;
        
        // Obstacles array
        const obstacles = [];
        
        // Create authentic Stereo Madness level layout
        function createLevel() {
            obstacles.length = 0;
            
            let x = 400; // Start position
            const B = BLOCK_SIZE; // Shorthand
            
            // === CUBE SECTION 1 (0% - 29%) ===
            
            // Opening spikes (0-3%)
            addSpike(x); x += B * 4;
            addSpike(x); x += B * 3;
            addSpike(x); x += B * 4;
            
            // First staircase (4-block ascending)
            for(let i = 0; i < 4; i++) {
                addBlock(x + i * B, groundY - B * (i + 1));
            } x += B * 6;
            
            // Single spike after staircase
            addSpike(x); x += B * 4;
            
            // Another spike
            addSpike(x); x += B * 3;
            
            // Two spikes close together
            addSpike(x);
            addSpike(x + B); x += B * 5;
            
            // Descending staircase (4-block descending)
            for(let i = 0; i < 4; i++) {
                addBlock(x + i * B, groundY - B * (4 - i));
            } x += B * 6;
            
            // Single jump
            addSpike(x); x += B * 4;
            
            // Platform sequence
            addPlatform(x, groundY - B * 3, B * 2);
            x += B * 5;
            addSpike(x); x += B * 3;
            
            // Another platform
            addPlatform(x, groundY - B * 4, B * 2);
            x += B * 5;
            
            // More spikes leading to ship
            addSpike(x); x += B * 3;
            addSpike(x); x += B * 4;
            addSpike(x); x += B * 3;
            
            // === SHIP PORTAL (29%) ===
            addShipPortal(x); x += B * 3;
            
            // === SHIP SECTION 1 (29% - 46%) ===
            
            // Ship obstacles - blocks and ceiling spikes
            for(let i = 0; i < 12; i++) {
                const spacing = B * 3;
                const currentX = x + i * spacing;
                
                if(i % 3 === 0) {
                    // Floor blocks
                    addBlock(currentX, groundY - B * 2);
                    addBlock(currentX, groundY - B);
                }
                if(i % 3 === 1) {
                    // Ceiling spikes
                    addCeilingSpike(currentX, B * 2);
                }
                if(i % 4 === 2) {
                    // Middle blocks
                    addBlock(currentX, groundY - B * 4);
                }
            }
            x += B * 36;
            
            // === CUBE PORTAL (46%) ===
            addCubePortal(x); x += B * 3;
            
            // === CUBE SECTION 2 (46% - 85%) ===
            
            // More challenging cube section
            addSpike(x); x += B * 3;
            addSpike(x); x += B * 2;
            addSpike(x); x += B * 4;
            
            // Another staircase (5 blocks)
            for(let i = 0; i < 5; i++) {
                addBlock(x + i * B, groundY - B * (i + 1));
            } x += B * 7;
            
            // Double spike
            addSpike(x);
            addSpike(x + B); x += B * 5;
            
            // Platform jump
            addPlatform(x, groundY - B * 3, B * 3);
            x += B * 6;
            
            // Descending blocks
            for(let i = 0; i < 3; i++) {
                addBlock(x + i * B, groundY - B * (3 - i));
            } x += B * 5;
            
            // Triple spike (challenging part)
            addSpike(x);
            addSpike(x + B);
            addSpike(x + B * 2); x += B * 6;
            
            // More spikes
            addSpike(x); x += B * 3;
            addSpike(x); x += B * 4;
            addSpike(x); x += B * 3;
            
            // === FINAL SHIP PORTAL (85%) ===
            addShipPortal(x); x += B * 3;
            
            // === FINAL SHIP SECTION (85% - 100%) ===
            
            // More challenging ship section
            for(let i = 0; i < 15; i++) {
                const spacing = B * 2.5;
                const currentX = x + i * spacing;
                
                if(i % 2 === 0) {
                    // Alternating floor and ceiling obstacles
                    addBlock(currentX, groundY - B * Math.floor(Math.random() * 3 + 1));
                }
                if(i % 3 === 1) {
                    addCeilingSpike(currentX, B * Math.floor(Math.random() * 2 + 2));
                }
                if(i % 4 === 3) {
                    addSpike(currentX, groundY - B);
                }
            }
            x += B * 40;
            
            // Final challenge - narrow passage
            for(let i = 0; i < 8; i++) {
                addBlock(x + i * B * 1.5, groundY - B * 3);
                addCeilingSpike(x + i * B * 1.5, B * 4);
            }
        }
        
        // Helper functions for creating obstacles
        function addSpike(x, y = groundY - BLOCK_SIZE) {
            obstacles.push({
                type: 'spike',
                x: x,
                y: y,
                width: BLOCK_SIZE,
                height: BLOCK_SIZE
            });
        }
        
        function addCeilingSpike(x, y) {
            obstacles.push({
                type: 'ceiling_spike',
                x: x,
                y: y,
                width: BLOCK_SIZE,
                height: BLOCK_SIZE
            });
        }
        
        function addBlock(x, y) {
            obstacles.push({
                type: 'block',
                x: x,
                y: y,
                width: BLOCK_SIZE,
                height: BLOCK_SIZE
            });
        }
        
        function addPlatform(x, y, width) {
            obstacles.push({
                type: 'platform',
                x: x,
                y: y,
                width: width,
                height: BLOCK_SIZE
            });
        }
        
        function addShipPortal(x) {
            obstacles.push({
                type: 'ship_portal',
                x: x,
                y: groundY - BLOCK_SIZE * 3,
                width: BLOCK_SIZE,
                height: BLOCK_SIZE * 3
            });
        }
        
        function addCubePortal(x) {
            obstacles.push({
                type: 'cube_portal',
                x: x,
                y: groundY - BLOCK_SIZE * 3,
                width: BLOCK_SIZE,
                height: BLOCK_SIZE * 3
            });
        }
        
        // Initialize level
        createLevel();
        
        // Calculate total level length for progress
        const LEVEL_LENGTH = obstacles.length > 0 ? Math.max(...obstacles.map(o => o.x)) + 200 : 3000;
        
        // Input handling
        let spacePressed = false;
        let mousePressed = false;
        
        function jump() {
            if (player.mode === 'cube' && player.onGround && gameRunning) {
                player.velY = player.jumpPower;
                player.jumping = true;
                player.onGround = false;
            } else if (player.mode === 'ship' && gameRunning) {
                player.velY = Math.max(player.velY - 1.5, -12);
            }
        }
        
        function stopJump() {
            if (player.mode === 'ship') {
                // Ship falls when not holding
            }
        }
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !spacePressed) {
                e.preventDefault();
                spacePressed = true;
                jump();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                spacePressed = false;
                stopJump();
            }
        });
        
        canvas.addEventListener('mousedown', () => {
            mousePressed = true;
            jump();
        });
        
        canvas.addEventListener('mouseup', () => {
            mousePressed = false;
            stopJump();
        });
        
        // Continuous ship control
        setInterval(() => {
            if (player.mode === 'ship' && gameRunning && (spacePressed || mousePressed)) {
                jump();
            }
        }, 16);
        
        // Game loop
        function update() {
            if (!gameRunning) return;
            
            // Move camera forward
            cameraX += gameSpeed;
            
            // Check for mode changes based on progress
            const progress = (cameraX / LEVEL_LENGTH) * 100;
            
            // Mode switching based on portals
            for (let obs of obstacles) {
                const obsScreenX = obs.x - cameraX;
                if (obs.type === 'ship_portal' && obsScreenX < player.x + player.width && obsScreenX > player.x - BLOCK_SIZE) {
                    player.mode = 'ship';
                } else if (obs.type === 'cube_portal' && obsScreenX < player.x + player.width && obsScreenX > player.x - BLOCK_SIZE) {
                    player.mode = 'cube';
                }
            }
            
            // Player physics
            if (player.mode === 'cube') {
                // Cube physics
                player.velY += player.gravity;
                player.y += player.velY;
                
                // Ground collision
                if (player.y + player.height >= groundY) {
                    player.y = groundY - player.height;
                    player.velY = 0;
                    player.onGround = true;
                    player.jumping = false;
                    
                    // Snap rotation
                    player.rotation = Math.round(player.rotation / (Math.PI/2)) * (Math.PI/2);
                } else {
                    player.onGround = false;
                }
                
                // Rotate cube when jumping
                if (player.jumping) {
                    player.rotation += 0.15;
                }
                
            } else if (player.mode === 'ship') {
                // Ship physics
                player.velY += 0.5; // Lighter gravity
                player.y += player.velY;
                
                // Ship boundaries
                if (player.y < BLOCK_SIZE) {
                    player.y = BLOCK_SIZE;
                    player.velY = 0;
                }
                if (player.y + player.height >= groundY) {
                    player.y = groundY - player.height;
                    player.velY = 0;
                }
                
                // Ship rotation
                player.rotation = Math.max(-0.3, Math.min(0.3, player.velY * 0.05));
                player.onGround = false;
            }
            
            // Platform collisions
            for (let obs of obstacles) {
                if (obs.type === 'platform') {
                    const obsScreenX = obs.x - cameraX;
                    if (player.x + player.width > obsScreenX && 
                        player.x < obsScreenX + obs.width &&
                        player.y + player.height > obs.y && 
                        player.y + player.height < obs.y + obs.height + 15 &&
                        player.velY > 0) {
                        
                        player.y = obs.y - player.height;
                        player.velY = 0;
                        player.onGround = true;
                        player.jumping = false;
                    }
                }
            }
            
            // Collision detection with obstacles
            for (let obs of obstacles) {
                if (obs.type === 'spike' || obs.type === 'block' || obs.type === 'ceiling_spike') {
                    const obsScreenX = obs.x - cameraX;
                    
                    // More forgiving collision detection
                    const margin = 3;
                    if (player.x + player.width - margin > obsScreenX + margin && 
                        player.x + margin < obsScreenX + obs.width - margin &&
                        player.y + player.height - margin > obs.y + margin && 
                        player.y + margin < obs.y + obs.height - margin) {
                        
                        // Game over
                        gameRunning = false;
                        document.getElementById('finalProgress').textContent = Math.floor(progress) + '%';
                        document.getElementById('gameOver').style.display = 'block';
                        return;
                    }
                }
            }
            
            // Update progress
            document.getElementById('progress').textContent = Math.floor(progress) + '%';
            
            // Win condition
            if (progress >= 100) {
                alert('Stereo Madness Complete! ðŸŽ‰');
                restart();
            }
        }
        
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            const gridSize = BLOCK_SIZE;
            const offsetX = (-cameraX) % gridSize;
            
            for (let x = offsetX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw ground
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
            
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(canvas.width, groundY);
            ctx.stroke();
            
            // Draw obstacles
            for (let obs of obstacles) {
                const x = obs.x - cameraX;
                
                // Only draw if on screen
                if (x > -obs.width && x < canvas.width) {
                    if (obs.type === 'spike') {
                        // Draw upward spike
                        ctx.fillStyle = '#FF0000';
                        ctx.strokeStyle = '#CC0000';
                        ctx.lineWidth = 2;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, obs.y + obs.height);
                        ctx.lineTo(x + obs.width/2, obs.y);
                        ctx.lineTo(x + obs.width, obs.y + obs.height);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                    } else if (obs.type === 'ceiling_spike') {
                        // Draw downward spike
                        ctx.fillStyle = '#FF0000';
                        ctx.strokeStyle = '#CC0000';
                        ctx.lineWidth = 2;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, obs.y);
                        ctx.lineTo(x + obs.width/2, obs.y + obs.height);
                        ctx.lineTo(x + obs.width, obs.y);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                    } else if (obs.type === 'block') {
                        // Draw block
                        ctx.fillStyle = '#666666';
                        ctx.fillRect(x, obs.y, obs.width, obs.height);
                        
                        ctx.strokeStyle = '#333333';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, obs.y, obs.width, obs.height);
                        
                    } else if (obs.type === 'platform') {
                        // Draw platform
                        ctx.fillStyle = '#CCCCCC';
                        ctx.fillRect(x, obs.y, obs.width, obs.height);
                        
                        ctx.strokeStyle = '#999999';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, obs.y, obs.width, obs.height);
                        
                    } else if (obs.type === 'ship_portal') {
                        // Draw ship portal
                        ctx.fillStyle = '#00FFFF';
                        ctx.fillRect(x, obs.y, obs.width, obs.height);
                        
                        ctx.strokeStyle = '#0088AA';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x, obs.y, obs.width, obs.height);
                        
                    } else if (obs.type === 'cube_portal') {
                        // Draw cube portal
                        ctx.fillStyle = '#FFFF00';
                        ctx.fillRect(x, obs.y, obs.width, obs.height);
                        
                        ctx.strokeStyle = '#CCCC00';
                        ctx.lineWidth = 3;
                        ctx.strokeRect(x, obs.y, obs.width, obs.height);
                    }
                }
            }
            
            // Draw player
            ctx.save();
            ctx.translate(player.x + player.width/2, player.y + player.height/2);
            ctx.rotate(player.rotation);
            
            if (player.mode === 'cube') {
                // Yellow cube
                ctx.fillStyle = '#FFFF00';
                ctx.fillRect(-player.width/2, -player.height/2, player.width, player.height);
                
                // Black outline
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 3;
                ctx.strokeRect(-player.width/2, -player.height/2, player.width, player.height);
                
                // Inner detail
                ctx.fillStyle = '#FFFF99';
                ctx.fillRect(-player.width/2 + 4, -player.height/2 + 4, player.width - 8, player.height - 8);
                
            } else if (player.mode === 'ship') {
                // Ship shape
                ctx.fillStyle = '#00FFFF';
                ctx.strokeStyle = '#000000';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.moveTo(-player.width/2, 0);
                ctx.lineTo(player.width/2, -player.height/3);
                ctx.lineTo(player.width/3, 0);
                ctx.lineTo(player.width/2, player.height/3);
                ctx.closePath();
                ctx.fill();
                ctx.stroke();
            }
            
            ctx.restore();
        }
        
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        function restart() {
            gameRunning = true;
            attempt++;
            cameraX = 0;
            player.x = 100;
            player.y = groundY - player.height;
            player.velY = 0;
            player.rotation = 0;
            player.onGround = true;
            player.jumping = false;
            player.mode = 'cube';
            
            document.getElementById('attempt').textContent = attempt;
            document.getElementById('gameOver').style.display = 'none';
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            const newGroundY = canvas.height - BLOCK_SIZE * 2;
            player.y = player.y + (newGroundY - groundY);
        });
        
        // Start the game
        gameLoop();
    </script>
</body>
</html>
