<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Dash - Stereo Madness</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(180deg, #87ceeb 0%, #4682b4 50%, #2f4f4f 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            cursor: pointer;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #title {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #ffff00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
        }
        button {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            border-radius: 25px;
            font-size: 18px;
            cursor: pointer;
        }
        button:hover {
            background: #ff5252;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div>Progress: <span id="progress">0%</span></div>
        <div>Attempt: <span id="attempt">1</span></div>
    </div>
    
    <div id="title">STEREO MADNESS</div>
    
    <div id="gameOver">
        <h2>Game Over!</h2>
        <p>Progress: <span id="finalProgress">0%</span></p>
        <button onclick="restart()">Try Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to full screen
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Game state
        let gameRunning = true;
        let attempt = 1;
        let cameraX = 0;
        let gameSpeed = 5;
        
        // Player
        const player = {
            x: 150,
            y: canvas.height - 200,
            width: 40,
            height: 40,
            velY: 0,
            jumping: false,
            onGround: true,
            rotation: 0
        };
        
        // Ground level
        const groundY = canvas.height - 100;
        
        // Obstacles array
        const obstacles = [];
        
        // Create initial obstacles (Stereo Madness pattern)
        function createLevel() {
            obstacles.length = 0; // Clear existing obstacles
            
            let x = 400;
            
            // Simple spike patterns like Stereo Madness
            obstacles.push({type: 'spike', x: x, y: groundY - 50, width: 40, height: 50}); x += 200;
            obstacles.push({type: 'spike', x: x, y: groundY - 50, width: 40, height: 50}); x += 150;
            obstacles.push({type: 'spike', x: x, y: groundY - 50, width: 40, height: 50}); x += 100;
            
            // Triple spike (famous pattern)
            obstacles.push({type: 'spike', x: x, y: groundY - 50, width: 40, height: 50});
            obstacles.push({type: 'spike', x: x + 50, y: groundY - 50, width: 40, height: 50});
            obstacles.push({type: 'spike', x: x + 100, y: groundY - 50, width: 40, height: 50}); x += 250;
            
            // Block obstacle
            obstacles.push({type: 'block', x: x, y: groundY - 100, width: 50, height: 50}); x += 200;
            
            // More spikes
            obstacles.push({type: 'spike', x: x, y: groundY - 50, width: 40, height: 50}); x += 150;
            obstacles.push({type: 'spike', x: x, y: groundY - 50, width: 40, height: 50}); x += 200;
            
            // Platform sequence
            obstacles.push({type: 'platform', x: x, y: groundY - 150, width: 100, height: 30}); x += 200;
            obstacles.push({type: 'spike', x: x, y: groundY - 50, width: 40, height: 50}); x += 150;
            
            // Final challenges
            for(let i = 0; i < 5; i++) {
                obstacles.push({type: 'spike', x: x + i * 120, y: groundY - 50, width: 40, height: 50});
            }
        }
        
        // Initialize level
        createLevel();
        
        // Input handling
        let spacePressed = false;
        
        function jump() {
            if (player.onGround && gameRunning) {
                player.velY = -18;
                player.jumping = true;
                player.onGround = false;
            }
        }
        
        // Event listeners
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !spacePressed) {
                e.preventDefault();
                spacePressed = true;
                jump();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                spacePressed = false;
            }
        });
        
        canvas.addEventListener('click', jump);
        
        // Game loop
        function update() {
            if (!gameRunning) return;
            
            // Move camera forward
            cameraX += gameSpeed;
            
            // Player physics
            player.velY += 0.8; // gravity
            player.y += player.velY;
            
            // Ground collision
            if (player.y + player.height >= groundY) {
                player.y = groundY - player.height;
                player.velY = 0;
                player.onGround = true;
                player.jumping = false;
                
                // Snap rotation to nearest 90 degrees
                player.rotation = Math.round(player.rotation / (Math.PI/2)) * (Math.PI/2);
            } else {
                player.onGround = false;
            }
            
            // Rotate player when jumping
            if (player.jumping) {
                player.rotation += 0.15;
            }
            
            // Platform collisions
            for (let obs of obstacles) {
                if (obs.type === 'platform') {
                    if (player.x + player.width > obs.x - cameraX && 
                        player.x < obs.x - cameraX + obs.width &&
                        player.y + player.height > obs.y && 
                        player.y + player.height < obs.y + obs.height + 20 &&
                        player.velY > 0) {
                        
                        player.y = obs.y - player.height;
                        player.velY = 0;
                        player.onGround = true;
                        player.jumping = false;
                    }
                }
            }
            
            // Collision detection
            for (let obs of obstacles) {
                if (obs.type === 'spike' || obs.type === 'block') {
                    const obsScreenX = obs.x - cameraX;
                    
                    if (player.x + player.width > obsScreenX + 5 && 
                        player.x < obsScreenX + obs.width - 5 &&
                        player.y + player.height > obs.y + 5 && 
                        player.y < obs.y + obs.height - 5) {
                        
                        // Game over
                        gameRunning = false;
                        document.getElementById('finalProgress').textContent = Math.floor((cameraX / 3000) * 100) + '%';
                        document.getElementById('gameOver').style.display = 'block';
                        return;
                    }
                }
            }
            
            // Update progress
            const progress = Math.floor((cameraX / 3000) * 100);
            document.getElementById('progress').textContent = progress + '%';
            
            // Win condition
            if (progress >= 100) {
                alert('Level Complete!');
                restart();
            }
        }
        
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            const offsetX = (-cameraX) % gridSize;
            
            for (let x = offsetX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw ground
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
            
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(canvas.width, groundY);
            ctx.stroke();
            
            // Draw obstacles
            for (let obs of obstacles) {
                const x = obs.x - cameraX;
                
                // Only draw if on screen
                if (x > -obs.width && x < canvas.width) {
                    if (obs.type === 'spike') {
                        // Draw spike
                        ctx.fillStyle = '#FF0000';
                        ctx.strokeStyle = '#CC0000';
                        ctx.lineWidth = 2;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, obs.y + obs.height);
                        ctx.lineTo(x + obs.width/2, obs.y);
                        ctx.lineTo(x + obs.width, obs.y + obs.height);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                    } else if (obs.type === 'block') {
                        // Draw block
                        ctx.fillStyle = '#666666';
                        ctx.fillRect(x, obs.y, obs.width, obs.height);
                        
                        ctx.strokeStyle = '#333333';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, obs.y, obs.width, obs.height);
                        
                    } else if (obs.type === 'platform') {
                        // Draw platform
                        ctx.fillStyle = '#CCCCCC';
                        ctx.fillRect(x, obs.y, obs.width, obs.height);
                        
                        ctx.strokeStyle = '#999999';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, obs.y, obs.width, obs.height);
                    }
                }
            }
            
            // Draw player (cube)
            ctx.save();
            ctx.translate(player.x + player.width/2, player.y + player.height/2);
            ctx.rotate(player.rotation);
            
            // Yellow cube
            ctx.fillStyle = '#FFFF00';
            ctx.fillRect(-player.width/2, -player.height/2, player.width, player.height);
            
            // Black outline
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeRect(-player.width/2, -player.height/2, player.width, player.height);
            
            // Inner detail
            ctx.fillStyle = '#FFFF99';
            ctx.fillRect(-player.width/2 + 5, -player.height/2 + 5, player.width - 10, player.height - 10);
            
            ctx.restore();
        }
        
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        function restart() {
            gameRunning = true;
            attempt++;
            cameraX = 0;
            player.x = 150;
            player.y = canvas.height - 200;
            player.velY = 0;
            player.rotation = 0;
            player.onGround = true;
            player.jumping = false;
            
            document.getElementById('attempt').textContent = attempt;
            document.getElementById('gameOver').style.display = 'none';
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            player.y = canvas.height - 200;
        });
        
        // Start the game
        gameLoop();
    </script>
</body>
</html>
