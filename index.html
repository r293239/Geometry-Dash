<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometry Dash - Stereo Madness</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: linear-gradient(180deg, #87ceeb 0%, #4682b4 50%, #2f4f4f 100%);
            font-family: Arial, sans-serif;
            overflow: hidden;
        }
        canvas {
            display: block;
            cursor: pointer;
        }
        #ui {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 20px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #title {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #ffff00;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
        }
        #gameOver {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9);
            color: white;
            padding: 30px;
            border-radius: 15px;
            text-align: center;
            display: none;
        }
        button {
            background: #ff6b6b;
            color: white;
            border: none;
            padding: 15px 30px;
            margin: 10px;
            border-radius: 25px;
            font-size: 18px;
            cursor: pointer;
        }
        button:hover {
            background: #ff5252;
        }
    </style>
</head>
<body>
    <canvas id="gameCanvas"></canvas>
    
    <div id="ui">
        <div>Progress: <span id="progress">0%</span></div>
        <div>Attempt: <span id="attempt">1</span></div>
    </div>
    
    <div id="title">STEREO MADNESS</div>
    
    <div id="gameOver">
        <h2>Game Over!</h2>
        <p>Progress: <span id="finalProgress">0%</span></p>
        <button onclick="restart()">Try Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        
        // Set canvas to full screen
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        
        // Game state
        let gameRunning = true;
        let attempt = 1;
        let cameraX = 0;
        let gameSpeed = 5;
        
        // Player
        const player = {
            x: 150,
            y: canvas.height - 200,
            width: 30,
            height: 30,
            velY: 0,
            jumping: false,
            onGround: true,
            rotation: 0,
            mode: 'cube' // cube or ship
        };
        
        // Ground level - standard 30px blocks
        const blockSize = 30;
        const groundY = canvas.height - blockSize * 3; // 3 blocks from bottom
        
        // Obstacles array
        const obstacles = [];
        
        // Create authentic Stereo Madness level layout
        function createLevel() {
            obstacles.length = 0; // Clear existing obstacles
            
            let x = 400;
            const blockH = blockSize;
            const spikeH = blockSize;
            
            // CUBE SECTION 1 (0% - 29%)
            
            // Opening - single spike
            obstacles.push({type: 'spike', x: x, y: groundY - spikeH, width: blockSize, height: spikeH}); x += blockSize * 4;
            
            // Another single spike  
            obstacles.push({type: 'spike', x: x, y: groundY - spikeH, width: blockSize, height: spikeH}); x += blockSize * 3;
            
            // Block obstacle (jump onto it)
            obstacles.push({type: 'block', x: x, y: groundY - blockH, width: blockSize, height: blockH}); x += blockSize * 4;
            
            // Single spike after block
            obstacles.push({type: 'spike', x: x, y: groundY - spikeH, width: blockSize, height: spikeH}); x += blockSize * 2;
            
            // THE FAMOUS TRIPLE SPIKE PATTERN (iconic Stereo Madness moment)
            obstacles.push({type: 'spike', x: x, y: groundY - spikeH, width: blockSize, height: spikeH});
            obstacles.push({type: 'spike', x: x + blockSize, y: groundY - spikeH, width: blockSize, height: spikeH});
            obstacles.push({type: 'spike', x: x + blockSize * 2, y: groundY - spikeH, width: blockSize, height: spikeH}); x += blockSize * 6;
            
            // More single spikes with proper spacing
            obstacles.push({type: 'spike', x: x, y: groundY - spikeH, width: blockSize, height: spikeH}); x += blockSize * 4;
            obstacles.push({type: 'spike', x: x, y: groundY - spikeH, width: blockSize, height: spikeH}); x += blockSize * 3;
            
            // Two blocks in a row (staircase start)
            obstacles.push({type: 'block', x: x, y: groundY - blockH, width: blockSize, height: blockH});
            obstacles.push({type: 'block', x: x + blockSize, y: groundY - blockH * 2, width: blockSize, height: blockH}); x += blockSize * 5;
            
            // Spike after staircase
            obstacles.push({type: 'spike', x: x, y: groundY - spikeH, width: blockSize, height: spikeH}); x += blockSize * 4;
            
            // Platform jump sequence (classic GD pattern)
            obstacles.push({type: 'platform', x: x, y: groundY - blockH * 3, width: blockSize * 2, height: blockH}); x += blockSize * 5;
            obstacles.push({type: 'spike', x: x, y: groundY - spikeH, width: blockSize, height: spikeH}); x += blockSize * 3;
            
            // SHIP SECTION 1 marker (29% - 46%)
            obstacles.push({type: 'ship_portal', x: x, y: groundY - blockH, width: blockSize, height: blockH * 2}); x += blockSize * 2;
            
            // Ship obstacles - blocks and ceiling spikes
            for(let i = 0; i < 8; i++) {
                if(i % 2 === 0) {
                    obstacles.push({type: 'block', x: x + i * blockSize * 2, y: groundY - blockH * 3, width: blockSize, height: blockH});
                }
                if(i % 3 === 1) {
                    obstacles.push({type: 'spike_down', x: x + i * blockSize * 2, y: blockSize * 2, width: blockSize, height: spikeH});
                }
            } x += blockSize * 16;
            
            // Back to CUBE marker (46%)
            obstacles.push({type: 'cube_portal', x: x, y: groundY - blockH, width: blockSize, height: blockH * 2}); x += blockSize * 2;
            
            // CUBE SECTION 2 (46% - 85%) - Harder patterns
            obstacles.push({type: 'spike', x: x, y: groundY - spikeH, width: blockSize, height: spikeH}); x += blockSize * 2;
            obstacles.push({type: 'spike', x: x, y: groundY - spikeH, width: blockSize, height: spikeH}); x += blockSize * 3;
            
            // Double spike pattern
            obstacles.push({type: 'spike', x: x, y: groundY - spikeH, width: blockSize, height: spikeH});
            obstacles.push({type: 'spike', x: x + blockSize, y: groundY - spikeH, width: blockSize, height: spikeH}); x += blockSize * 5;
            
            // Block staircase (step pattern)
            for(let i = 0; i < 4; i++) {
                obstacles.push({type: 'block', x: x + i * blockSize, y: groundY - blockH * (i + 1), width: blockSize, height: blockH});
            } x += blockSize * 7;
            
            // More challenging spikes
            obstacles.push({type: 'spike', x: x, y: groundY - spikeH, width: blockSize, height: spikeH}); x += blockSize * 3;
            obstacles.push({type: 'spike', x: x, y: groundY - spikeH, width: blockSize, height: spikeH}); x += blockSize * 2;
            obstacles.push({type: 'spike', x: x, y: groundY - spikeH, width: blockSize, height: spikeH}); x += blockSize * 4;
            
            // FINAL SHIP SECTION marker (85% - 100%)
            obstacles.push({type: 'ship_portal', x: x, y: groundY - blockH, width: blockSize, height: blockH * 2}); x += blockSize * 2;
            
            // Final ship challenge - more dense obstacles
            for(let i = 0; i < 10; i++) {
                if(i % 2 === 0) {
                    obstacles.push({type: 'block', x: x + i * blockSize * 1.5, y: groundY - blockH * 4 + Math.sin(i) * blockH, width: blockSize, height: blockH});
                }
                if(i % 3 === 1) {
                    obstacles.push({type: 'spike_down', x: x + i * blockSize * 1.5, y: blockSize * 2, width: blockSize, height: spikeH});
                }
                if(i % 4 === 2) {
                    obstacles.push({type: 'spike', x: x + i * blockSize * 1.5, y: groundY - spikeH * 2, width: blockSize, height: spikeH});
                }
            }
        }
        
        // Initialize level
        createLevel();
        
        // Input handling
        let spacePressed = false;
        
        function jump() {
            if (player.mode === 'cube' && player.onGround && gameRunning) {
                // Authentic GD cube jump - exactly 3 blocks high (2.1333 blocks precisely)
                player.velY = -15.5; // This gives approximately 3 block jump height
                player.jumping = true;
                player.onGround = false;
            } else if (player.mode === 'ship' && gameRunning) {
                // Ship mode - continuous thrust
                player.velY = Math.max(player.velY - 1.2, -12); // Upward thrust with max speed
            }
        }
        
        function stopJump() {
            if (player.mode === 'ship') {
                // Ship falls when not holding
                // Natural gravity will take over
            }
        }
        
        // Event listeners - updated for ship mode
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space' && !spacePressed) {
                e.preventDefault();
                spacePressed = true;
                jump();
            }
        });
        
        document.addEventListener('keyup', (e) => {
            if (e.code === 'Space') {
                spacePressed = false;
                stopJump();
            }
        });
        
        let mousePressed = false;
        canvas.addEventListener('mousedown', () => {
            mousePressed = true;
            jump();
        });
        
        canvas.addEventListener('mouseup', () => {
            mousePressed = false;
            stopJump();
        });
        
        // Continuous ship control
        function handleShipControl() {
            if (player.mode === 'ship' && gameRunning && (spacePressed || mousePressed)) {
                jump(); // Continuous thrust while held
            }
        }
        
        setInterval(handleShipControl, 16); // 60 FPS control
        
        // Game loop
        function update() {
            if (!gameRunning) return;
            
            // Move camera forward
            cameraX += gameSpeed;
            
            // Check for mode changes based on progress (authentic Stereo Madness)
            const progress = (cameraX / 3000) * 100;
            if (progress >= 29 && progress < 46) {
                player.mode = 'ship';
            } else if (progress >= 85) {
                player.mode = 'ship';
            } else {
                player.mode = 'cube';
            }
            
            // Player physics
            if (player.mode === 'cube') {
                // Cube physics
                player.velY += 0.7; // gravity for cube
                player.y += player.velY;
                
                // Ground collision
                if (player.y + player.height >= groundY) {
                    player.y = groundY - player.height;
                    player.velY = 0;
                    player.onGround = true;
                    player.jumping = false;
                    
                    // Snap rotation to nearest 90 degrees
                    player.rotation = Math.round(player.rotation / (Math.PI/2)) * (Math.PI/2);
                } else {
                    player.onGround = false;
                }
                
                // Rotate cube when jumping
                if (player.jumping) {
                    player.rotation += 0.12;
                }
                
            } else if (player.mode === 'ship') {
                // Ship physics
                player.velY += 0.4; // lighter gravity for ship
                player.y += player.velY;
                
                // Ship boundaries
                if (player.y < blockSize) {
                    player.y = blockSize;
                    player.velY = 0;
                }
                if (player.y + player.height >= groundY) {
                    player.y = groundY - player.height;
                    player.velY = 0;
                }
                
                // Ship rotation based on velocity
                player.rotation = player.velY * 0.03;
                player.onGround = false;
            }
            
            // Platform collisions
            for (let obs of obstacles) {
                if (obs.type === 'platform') {
                    if (player.x + player.width > obs.x - cameraX && 
                        player.x < obs.x - cameraX + obs.width &&
                        player.y + player.height > obs.y && 
                        player.y + player.height < obs.y + obs.height + 20 &&
                        player.velY > 0) {
                        
                        player.y = obs.y - player.height;
                        player.velY = 0;
                        player.onGround = true;
                        player.jumping = false;
                    }
                }
            }
            
            // Collision detection
            for (let obs of obstacles) {
                if (obs.type === 'spike' || obs.type === 'block' || obs.type === 'spike_down') {
                    const obsScreenX = obs.x - cameraX;
                    
                    if (player.x + player.width > obsScreenX + 3 && 
                        player.x < obsScreenX + obs.width - 3 &&
                        player.y + player.height > obs.y + 3 && 
                        player.y < obs.y + obs.height - 3) {
                        
                        // Game over
                        gameRunning = false;
                        document.getElementById('finalProgress').textContent = Math.floor(progress) + '%';
                        document.getElementById('gameOver').style.display = 'block';
                        return;
                    }
                }
            }
            
            // Update progress
            document.getElementById('progress').textContent = Math.floor(progress) + '%';
            
            // Win condition
            if (progress >= 100) {
                alert('Stereo Madness Complete! 🎉');
                restart();
            }
        }
        
        function draw() {
            // Clear canvas
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            
            // Draw background grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
            ctx.lineWidth = 1;
            
            const gridSize = 50;
            const offsetX = (-cameraX) % gridSize;
            
            for (let x = offsetX; x < canvas.width; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, canvas.height);
                ctx.stroke();
            }
            
            for (let y = 0; y < canvas.height; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(canvas.width, y);
                ctx.stroke();
            }
            
            // Draw ground
            ctx.fillStyle = '#8B4513';
            ctx.fillRect(0, groundY, canvas.width, canvas.height - groundY);
            
            ctx.strokeStyle = '#654321';
            ctx.lineWidth = 3;
            ctx.beginPath();
            ctx.moveTo(0, groundY);
            ctx.lineTo(canvas.width, groundY);
            ctx.stroke();
            
            // Draw obstacles
            for (let obs of obstacles) {
                const x = obs.x - cameraX;
                
                // Only draw if on screen
                if (x > -obs.width && x < canvas.width) {
                    if (obs.type === 'spike') {
                        // Draw spike
                        ctx.fillStyle = '#FF0000';
                        ctx.strokeStyle = '#CC0000';
                        ctx.lineWidth = 2;
                        
                        ctx.beginPath();
                        ctx.moveTo(x, obs.y + obs.height);
                        ctx.lineTo(x + obs.width/2, obs.y);
                        ctx.lineTo(x + obs.width, obs.y + obs.height);
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        
                    } else if (obs.type === 'block') {
                        // Draw block
                        ctx.fillStyle = '#666666';
                        ctx.fillRect(x, obs.y, obs.width, obs.height);
                        
                        ctx.strokeStyle = '#333333';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, obs.y, obs.width, obs.height);
                        
                    } else if (obs.type === 'platform') {
                        // Draw platform
                        ctx.fillStyle = '#CCCCCC';
                        ctx.fillRect(x, obs.y, obs.width, obs.height);
                        
                        ctx.strokeStyle = '#999999';
                        ctx.lineWidth = 2;
                        ctx.strokeRect(x, obs.y, obs.width, obs.height);
                    }
                }
            }
            
            // Draw player (cube)
            ctx.save();
            ctx.translate(player.x + player.width/2, player.y + player.height/2);
            ctx.rotate(player.rotation);
            
            // Yellow cube
            ctx.fillStyle = '#FFFF00';
            ctx.fillRect(-player.width/2, -player.height/2, player.width, player.height);
            
            // Black outline
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 3;
            ctx.strokeRect(-player.width/2, -player.height/2, player.width, player.height);
            
            // Inner detail
            ctx.fillStyle = '#FFFF99';
            ctx.fillRect(-player.width/2 + 5, -player.height/2 + 5, player.width - 10, player.height - 10);
            
            ctx.restore();
        }
        
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        function restart() {
            gameRunning = true;
            attempt++;
            cameraX = 0;
            player.x = 150;
            player.y = canvas.height - 200;
            player.velY = 0;
            player.rotation = 0;
            player.onGround = true;
            player.jumping = false;
            
            document.getElementById('attempt').textContent = attempt;
            document.getElementById('gameOver').style.display = 'none';
        }
        
        // Handle window resize
        window.addEventListener('resize', () => {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            player.y = canvas.height - 200;
        });
        
        // Start the game
        gameLoop();
    </script>
</body>
</html>
